/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Layer, Uint128, Decimal, Percent, ContractStateParams, Coin, IntervalRewardingParamsUpdate, LayerAssignment, MixNodeCostParams, MixNode, MixNodeConfigUpdate, Gateway, InstantiateMsg, Duration, InitialRewardingParams, MigrateMsg, QueryMsg } from "./NymMixnetContract.types";
export interface NymMixnetContractReadOnlyInterface {
  contractAddress: string;
  getAllFamiliesPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAllFamiliesPagedResponse>;
  getAllMembersPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAllMembersPagedResponse>;
  getFamilyByHead: ({
    head
  }: {
    head: string;
  }) => Promise<GetFamilyByHeadResponse>;
  getFamilyByLabel: ({
    label
  }: {
    label: string;
  }) => Promise<GetFamilyByLabelResponse>;
  getFamilyMembersByHead: ({
    head
  }: {
    head: string;
  }) => Promise<GetFamilyMembersByHeadResponse>;
  getFamilyMembersByLabel: ({
    label
  }: {
    label: string;
  }) => Promise<GetFamilyMembersByLabelResponse>;
  getContractVersion: () => Promise<GetContractVersionResponse>;
  getRewardingValidatorAddress: () => Promise<GetRewardingValidatorAddressResponse>;
  getStateParams: () => Promise<GetStateParamsResponse>;
  getState: () => Promise<GetStateResponse>;
  getRewardingParams: () => Promise<GetRewardingParamsResponse>;
  getCurrentIntervalDetails: () => Promise<GetCurrentIntervalDetailsResponse>;
  getRewardedSet: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetRewardedSetResponse>;
  getMixNodeBonds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetMixNodeBondsResponse>;
  getMixNodesDetailed: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetMixNodesDetailedResponse>;
  getUnbondedMixNodes: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetUnbondedMixNodesResponse>;
  getUnbondedMixNodesByOwner: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }) => Promise<GetUnbondedMixNodesByOwnerResponse>;
  getUnbondedMixNodesByIdentityKey: ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<GetUnbondedMixNodesByIdentityKeyResponse>;
  getOwnedMixnode: ({
    address
  }: {
    address: string;
  }) => Promise<GetOwnedMixnodeResponse>;
  getMixnodeDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<GetMixnodeDetailsResponse>;
  getMixnodeRewardingDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<GetMixnodeRewardingDetailsResponse>;
  getStakeSaturation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<GetStakeSaturationResponse>;
  getUnbondedMixNodeInformation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<GetUnbondedMixNodeInformationResponse>;
  getBondedMixnodeDetailsByIdentity: ({
    mixIdentity
  }: {
    mixIdentity: string;
  }) => Promise<GetBondedMixnodeDetailsByIdentityResponse>;
  getLayerDistribution: () => Promise<GetLayerDistributionResponse>;
  getGateways: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetGatewaysResponse>;
  getGatewayBond: ({
    identity
  }: {
    identity: string;
  }) => Promise<GetGatewayBondResponse>;
  getOwnedGateway: ({
    address
  }: {
    address: string;
  }) => Promise<GetOwnedGatewayResponse>;
  getMixnodeDelegations: ({
    limit,
    mixId,
    startAfter
  }: {
    limit?: number;
    mixId: number;
    startAfter?: string;
  }) => Promise<GetMixnodeDelegationsResponse>;
  getDelegatorDelegations: ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetDelegatorDelegationsResponse>;
  getDelegationDetails: ({
    delegator,
    mixId,
    proxy
  }: {
    delegator: string;
    mixId: number;
    proxy?: string;
  }) => Promise<GetDelegationDetailsResponse>;
  getAllDelegations: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetAllDelegationsResponse>;
  getPendingOperatorReward: ({
    address
  }: {
    address: string;
  }) => Promise<GetPendingOperatorRewardResponse>;
  getPendingMixNodeOperatorReward: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<GetPendingMixNodeOperatorRewardResponse>;
  getPendingDelegatorReward: ({
    address,
    mixId,
    proxy
  }: {
    address: string;
    mixId: number;
    proxy?: string;
  }) => Promise<GetPendingDelegatorRewardResponse>;
  getEstimatedCurrentEpochOperatorReward: ({
    estimatedPerformance,
    mixId
  }: {
    estimatedPerformance: Percent;
    mixId: number;
  }) => Promise<GetEstimatedCurrentEpochOperatorRewardResponse>;
  getEstimatedCurrentEpochDelegatorReward: ({
    address,
    estimatedPerformance,
    mixId,
    proxy
  }: {
    address: string;
    estimatedPerformance: Percent;
    mixId: number;
    proxy?: string;
  }) => Promise<GetEstimatedCurrentEpochDelegatorRewardResponse>;
  getPendingEpochEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetPendingEpochEventsResponse>;
  getPendingIntervalEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<GetPendingIntervalEventsResponse>;
}
export class NymMixnetContractQueryClient implements NymMixnetContractReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getAllFamiliesPaged = this.getAllFamiliesPaged.bind(this);
    this.getAllMembersPaged = this.getAllMembersPaged.bind(this);
    this.getFamilyByHead = this.getFamilyByHead.bind(this);
    this.getFamilyByLabel = this.getFamilyByLabel.bind(this);
    this.getFamilyMembersByHead = this.getFamilyMembersByHead.bind(this);
    this.getFamilyMembersByLabel = this.getFamilyMembersByLabel.bind(this);
    this.getContractVersion = this.getContractVersion.bind(this);
    this.getRewardingValidatorAddress = this.getRewardingValidatorAddress.bind(this);
    this.getStateParams = this.getStateParams.bind(this);
    this.getState = this.getState.bind(this);
    this.getRewardingParams = this.getRewardingParams.bind(this);
    this.getCurrentIntervalDetails = this.getCurrentIntervalDetails.bind(this);
    this.getRewardedSet = this.getRewardedSet.bind(this);
    this.getMixNodeBonds = this.getMixNodeBonds.bind(this);
    this.getMixNodesDetailed = this.getMixNodesDetailed.bind(this);
    this.getUnbondedMixNodes = this.getUnbondedMixNodes.bind(this);
    this.getUnbondedMixNodesByOwner = this.getUnbondedMixNodesByOwner.bind(this);
    this.getUnbondedMixNodesByIdentityKey = this.getUnbondedMixNodesByIdentityKey.bind(this);
    this.getOwnedMixnode = this.getOwnedMixnode.bind(this);
    this.getMixnodeDetails = this.getMixnodeDetails.bind(this);
    this.getMixnodeRewardingDetails = this.getMixnodeRewardingDetails.bind(this);
    this.getStakeSaturation = this.getStakeSaturation.bind(this);
    this.getUnbondedMixNodeInformation = this.getUnbondedMixNodeInformation.bind(this);
    this.getBondedMixnodeDetailsByIdentity = this.getBondedMixnodeDetailsByIdentity.bind(this);
    this.getLayerDistribution = this.getLayerDistribution.bind(this);
    this.getGateways = this.getGateways.bind(this);
    this.getGatewayBond = this.getGatewayBond.bind(this);
    this.getOwnedGateway = this.getOwnedGateway.bind(this);
    this.getMixnodeDelegations = this.getMixnodeDelegations.bind(this);
    this.getDelegatorDelegations = this.getDelegatorDelegations.bind(this);
    this.getDelegationDetails = this.getDelegationDetails.bind(this);
    this.getAllDelegations = this.getAllDelegations.bind(this);
    this.getPendingOperatorReward = this.getPendingOperatorReward.bind(this);
    this.getPendingMixNodeOperatorReward = this.getPendingMixNodeOperatorReward.bind(this);
    this.getPendingDelegatorReward = this.getPendingDelegatorReward.bind(this);
    this.getEstimatedCurrentEpochOperatorReward = this.getEstimatedCurrentEpochOperatorReward.bind(this);
    this.getEstimatedCurrentEpochDelegatorReward = this.getEstimatedCurrentEpochDelegatorReward.bind(this);
    this.getPendingEpochEvents = this.getPendingEpochEvents.bind(this);
    this.getPendingIntervalEvents = this.getPendingIntervalEvents.bind(this);
  }

  getAllFamiliesPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAllFamiliesPagedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_families_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAllMembersPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAllMembersPagedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_members_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getFamilyByHead = async ({
    head
  }: {
    head: string;
  }): Promise<GetFamilyByHeadResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_by_head: {
        head
      }
    });
  };
  getFamilyByLabel = async ({
    label
  }: {
    label: string;
  }): Promise<GetFamilyByLabelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_by_label: {
        label
      }
    });
  };
  getFamilyMembersByHead = async ({
    head
  }: {
    head: string;
  }): Promise<GetFamilyMembersByHeadResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_members_by_head: {
        head
      }
    });
  };
  getFamilyMembersByLabel = async ({
    label
  }: {
    label: string;
  }): Promise<GetFamilyMembersByLabelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_members_by_label: {
        label
      }
    });
  };
  getContractVersion = async (): Promise<GetContractVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_version: {}
    });
  };
  getRewardingValidatorAddress = async (): Promise<GetRewardingValidatorAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_validator_address: {}
    });
  };
  getStateParams = async (): Promise<GetStateParamsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state_params: {}
    });
  };
  getState = async (): Promise<GetStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state: {}
    });
  };
  getRewardingParams = async (): Promise<GetRewardingParamsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_params: {}
    });
  };
  getCurrentIntervalDetails = async (): Promise<GetCurrentIntervalDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_interval_details: {}
    });
  };
  getRewardedSet = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetRewardedSetResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarded_set: {
        limit,
        start_after: startAfter
      }
    });
  };
  getMixNodeBonds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetMixNodeBondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_node_bonds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getMixNodesDetailed = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetMixNodesDetailedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_nodes_detailed: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodes = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetUnbondedMixNodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByOwner = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }): Promise<GetUnbondedMixNodesByOwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_owner: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByIdentityKey = async ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }): Promise<GetUnbondedMixNodesByIdentityKeyResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_identity_key: {
        identity_key: identityKey,
        limit,
        start_after: startAfter
      }
    });
  };
  getOwnedMixnode = async ({
    address
  }: {
    address: string;
  }): Promise<GetOwnedMixnodeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_mixnode: {
        address
      }
    });
  };
  getMixnodeDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<GetMixnodeDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_details: {
        mix_id: mixId
      }
    });
  };
  getMixnodeRewardingDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<GetMixnodeRewardingDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_rewarding_details: {
        mix_id: mixId
      }
    });
  };
  getStakeSaturation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<GetStakeSaturationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_stake_saturation: {
        mix_id: mixId
      }
    });
  };
  getUnbondedMixNodeInformation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<GetUnbondedMixNodeInformationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_node_information: {
        mix_id: mixId
      }
    });
  };
  getBondedMixnodeDetailsByIdentity = async ({
    mixIdentity
  }: {
    mixIdentity: string;
  }): Promise<GetBondedMixnodeDetailsByIdentityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bonded_mixnode_details_by_identity: {
        mix_identity: mixIdentity
      }
    });
  };
  getLayerDistribution = async (): Promise<GetLayerDistributionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_layer_distribution: {}
    });
  };
  getGateways = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetGatewaysResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateways: {
        limit,
        start_after: startAfter
      }
    });
  };
  getGatewayBond = async ({
    identity
  }: {
    identity: string;
  }): Promise<GetGatewayBondResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateway_bond: {
        identity
      }
    });
  };
  getOwnedGateway = async ({
    address
  }: {
    address: string;
  }): Promise<GetOwnedGatewayResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_gateway: {
        address
      }
    });
  };
  getMixnodeDelegations = async ({
    limit,
    mixId,
    startAfter
  }: {
    limit?: number;
    mixId: number;
    startAfter?: string;
  }): Promise<GetMixnodeDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_delegations: {
        limit,
        mix_id: mixId,
        start_after: startAfter
      }
    });
  };
  getDelegatorDelegations = async ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetDelegatorDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegator_delegations: {
        delegator,
        limit,
        start_after: startAfter
      }
    });
  };
  getDelegationDetails = async ({
    delegator,
    mixId,
    proxy
  }: {
    delegator: string;
    mixId: number;
    proxy?: string;
  }): Promise<GetDelegationDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegation_details: {
        delegator,
        mix_id: mixId,
        proxy
      }
    });
  };
  getAllDelegations = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetAllDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_delegations: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingOperatorReward = async ({
    address
  }: {
    address: string;
  }): Promise<GetPendingOperatorRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_operator_reward: {
        address
      }
    });
  };
  getPendingMixNodeOperatorReward = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<GetPendingMixNodeOperatorRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_mix_node_operator_reward: {
        mix_id: mixId
      }
    });
  };
  getPendingDelegatorReward = async ({
    address,
    mixId,
    proxy
  }: {
    address: string;
    mixId: number;
    proxy?: string;
  }): Promise<GetPendingDelegatorRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_delegator_reward: {
        address,
        mix_id: mixId,
        proxy
      }
    });
  };
  getEstimatedCurrentEpochOperatorReward = async ({
    estimatedPerformance,
    mixId
  }: {
    estimatedPerformance: Percent;
    mixId: number;
  }): Promise<GetEstimatedCurrentEpochOperatorRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_operator_reward: {
        estimated_performance: estimatedPerformance,
        mix_id: mixId
      }
    });
  };
  getEstimatedCurrentEpochDelegatorReward = async ({
    address,
    estimatedPerformance,
    mixId,
    proxy
  }: {
    address: string;
    estimatedPerformance: Percent;
    mixId: number;
    proxy?: string;
  }): Promise<GetEstimatedCurrentEpochDelegatorRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_delegator_reward: {
        address,
        estimated_performance: estimatedPerformance,
        mix_id: mixId,
        proxy
      }
    });
  };
  getPendingEpochEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetPendingEpochEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_epoch_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingIntervalEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<GetPendingIntervalEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_interval_events: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface NymMixnetContractInterface extends NymMixnetContractReadOnlyInterface {
  contractAddress: string;
  sender: string;
  assignNodeLayer: ({
    layer,
    mixId
  }: {
    layer: Layer;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createFamily: ({
    label,
    ownerSignature
  }: {
    label: string;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinFamily: ({
    familyHead,
    signature
  }: {
    familyHead: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveFamily: ({
    familyHead,
    signature
  }: {
    familyHead: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  kickFamilyMember: ({
    member,
    signature
  }: {
    member: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createFamilyOnBehalf: ({
    label,
    ownerAddress,
    ownerSignature
  }: {
    label: string;
    ownerAddress: string;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinFamilyOnBehalf: ({
    familyHead,
    memberAddress,
    signature
  }: {
    familyHead: string;
    memberAddress: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveFamilyOnBehalf: ({
    familyHead,
    memberAddress,
    signature
  }: {
    familyHead: string;
    memberAddress: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  kickFamilyMemberOnBehalf: ({
    headAddress,
    member,
    signature
  }: {
    headAddress: string;
    member: string;
    signature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewardingValidatorAddress: ({
    address
  }: {
    address: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateContractStateParams: ({
    updatedParameters
  }: {
    updatedParameters: ContractStateParams;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateActiveSetSize: ({
    activeSetSize,
    forceImmediately
  }: {
    activeSetSize: number;
    forceImmediately: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewardingParams: ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateIntervalConfig: ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  advanceCurrentEpoch: ({
    expectedActiveSetSize,
    newRewardedSet
  }: {
    expectedActiveSetSize: number;
    newRewardedSet: LayerAssignment[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reconcileEpochEvents: ({
    limit
  }: {
    limit?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondMixnode: ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondMixnodeOnBehalf: ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pledgeMore: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pledgeMoreOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondMixnode: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondMixnodeOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeCostParams: ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeCostParamsOnBehalf: ({
    newCosts,
    owner
  }: {
    newCosts: MixNodeCostParams;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeConfig: ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeConfigOnBehalf: ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondGateway: ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondGatewayOnBehalf: ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondGateway: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondGatewayOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateToMixnode: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateToMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  undelegateFromMixnode: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  undelegateFromMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rewardMixnode: ({
    mixId,
    performance
  }: {
    mixId: number;
    performance: Percent;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawOperatorReward: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawOperatorRewardOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawDelegatorReward: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawDelegatorRewardOnBehalf: ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class NymMixnetContractClient extends NymMixnetContractQueryClient implements NymMixnetContractInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.assignNodeLayer = this.assignNodeLayer.bind(this);
    this.createFamily = this.createFamily.bind(this);
    this.joinFamily = this.joinFamily.bind(this);
    this.leaveFamily = this.leaveFamily.bind(this);
    this.kickFamilyMember = this.kickFamilyMember.bind(this);
    this.createFamilyOnBehalf = this.createFamilyOnBehalf.bind(this);
    this.joinFamilyOnBehalf = this.joinFamilyOnBehalf.bind(this);
    this.leaveFamilyOnBehalf = this.leaveFamilyOnBehalf.bind(this);
    this.kickFamilyMemberOnBehalf = this.kickFamilyMemberOnBehalf.bind(this);
    this.updateRewardingValidatorAddress = this.updateRewardingValidatorAddress.bind(this);
    this.updateContractStateParams = this.updateContractStateParams.bind(this);
    this.updateActiveSetSize = this.updateActiveSetSize.bind(this);
    this.updateRewardingParams = this.updateRewardingParams.bind(this);
    this.updateIntervalConfig = this.updateIntervalConfig.bind(this);
    this.advanceCurrentEpoch = this.advanceCurrentEpoch.bind(this);
    this.reconcileEpochEvents = this.reconcileEpochEvents.bind(this);
    this.bondMixnode = this.bondMixnode.bind(this);
    this.bondMixnodeOnBehalf = this.bondMixnodeOnBehalf.bind(this);
    this.pledgeMore = this.pledgeMore.bind(this);
    this.pledgeMoreOnBehalf = this.pledgeMoreOnBehalf.bind(this);
    this.unbondMixnode = this.unbondMixnode.bind(this);
    this.unbondMixnodeOnBehalf = this.unbondMixnodeOnBehalf.bind(this);
    this.updateMixnodeCostParams = this.updateMixnodeCostParams.bind(this);
    this.updateMixnodeCostParamsOnBehalf = this.updateMixnodeCostParamsOnBehalf.bind(this);
    this.updateMixnodeConfig = this.updateMixnodeConfig.bind(this);
    this.updateMixnodeConfigOnBehalf = this.updateMixnodeConfigOnBehalf.bind(this);
    this.bondGateway = this.bondGateway.bind(this);
    this.bondGatewayOnBehalf = this.bondGatewayOnBehalf.bind(this);
    this.unbondGateway = this.unbondGateway.bind(this);
    this.unbondGatewayOnBehalf = this.unbondGatewayOnBehalf.bind(this);
    this.delegateToMixnode = this.delegateToMixnode.bind(this);
    this.delegateToMixnodeOnBehalf = this.delegateToMixnodeOnBehalf.bind(this);
    this.undelegateFromMixnode = this.undelegateFromMixnode.bind(this);
    this.undelegateFromMixnodeOnBehalf = this.undelegateFromMixnodeOnBehalf.bind(this);
    this.rewardMixnode = this.rewardMixnode.bind(this);
    this.withdrawOperatorReward = this.withdrawOperatorReward.bind(this);
    this.withdrawOperatorRewardOnBehalf = this.withdrawOperatorRewardOnBehalf.bind(this);
    this.withdrawDelegatorReward = this.withdrawDelegatorReward.bind(this);
    this.withdrawDelegatorRewardOnBehalf = this.withdrawDelegatorRewardOnBehalf.bind(this);
  }

  assignNodeLayer = async ({
    layer,
    mixId
  }: {
    layer: Layer;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      assign_node_layer: {
        layer,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  createFamily = async ({
    label,
    ownerSignature
  }: {
    label: string;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_family: {
        label,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  joinFamily = async ({
    familyHead,
    signature
  }: {
    familyHead: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_family: {
        family_head: familyHead,
        signature
      }
    }, fee, memo, _funds);
  };
  leaveFamily = async ({
    familyHead,
    signature
  }: {
    familyHead: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_family: {
        family_head: familyHead,
        signature
      }
    }, fee, memo, _funds);
  };
  kickFamilyMember = async ({
    member,
    signature
  }: {
    member: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      kick_family_member: {
        member,
        signature
      }
    }, fee, memo, _funds);
  };
  createFamilyOnBehalf = async ({
    label,
    ownerAddress,
    ownerSignature
  }: {
    label: string;
    ownerAddress: string;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_family_on_behalf: {
        label,
        owner_address: ownerAddress,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  joinFamilyOnBehalf = async ({
    familyHead,
    memberAddress,
    signature
  }: {
    familyHead: string;
    memberAddress: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_family_on_behalf: {
        family_head: familyHead,
        member_address: memberAddress,
        signature
      }
    }, fee, memo, _funds);
  };
  leaveFamilyOnBehalf = async ({
    familyHead,
    memberAddress,
    signature
  }: {
    familyHead: string;
    memberAddress: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_family_on_behalf: {
        family_head: familyHead,
        member_address: memberAddress,
        signature
      }
    }, fee, memo, _funds);
  };
  kickFamilyMemberOnBehalf = async ({
    headAddress,
    member,
    signature
  }: {
    headAddress: string;
    member: string;
    signature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      kick_family_member_on_behalf: {
        head_address: headAddress,
        member,
        signature
      }
    }, fee, memo, _funds);
  };
  updateRewardingValidatorAddress = async ({
    address
  }: {
    address: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_validator_address: {
        address
      }
    }, fee, memo, _funds);
  };
  updateContractStateParams = async ({
    updatedParameters
  }: {
    updatedParameters: ContractStateParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contract_state_params: {
        updated_parameters: updatedParameters
      }
    }, fee, memo, _funds);
  };
  updateActiveSetSize = async ({
    activeSetSize,
    forceImmediately
  }: {
    activeSetSize: number;
    forceImmediately: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_active_set_size: {
        active_set_size: activeSetSize,
        force_immediately: forceImmediately
      }
    }, fee, memo, _funds);
  };
  updateRewardingParams = async ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_params: {
        force_immediately: forceImmediately,
        updated_params: updatedParams
      }
    }, fee, memo, _funds);
  };
  updateIntervalConfig = async ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_interval_config: {
        epoch_duration_secs: epochDurationSecs,
        epochs_in_interval: epochsInInterval,
        force_immediately: forceImmediately
      }
    }, fee, memo, _funds);
  };
  advanceCurrentEpoch = async ({
    expectedActiveSetSize,
    newRewardedSet
  }: {
    expectedActiveSetSize: number;
    newRewardedSet: LayerAssignment[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      advance_current_epoch: {
        expected_active_set_size: expectedActiveSetSize,
        new_rewarded_set: newRewardedSet
      }
    }, fee, memo, _funds);
  };
  reconcileEpochEvents = async ({
    limit
  }: {
    limit?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reconcile_epoch_events: {
        limit
      }
    }, fee, memo, _funds);
  };
  bondMixnode = async ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode: {
        cost_params: costParams,
        mix_node: mixNode,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  bondMixnodeOnBehalf = async ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode_on_behalf: {
        cost_params: costParams,
        mix_node: mixNode,
        owner,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  pledgeMore = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more: {}
    }, fee, memo, _funds);
  };
  pledgeMoreOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  unbondMixnode = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode: {}
    }, fee, memo, _funds);
  };
  unbondMixnodeOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  updateMixnodeCostParams = async ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params: {
        new_costs: newCosts
      }
    }, fee, memo, _funds);
  };
  updateMixnodeCostParamsOnBehalf = async ({
    newCosts,
    owner
  }: {
    newCosts: MixNodeCostParams;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params_on_behalf: {
        new_costs: newCosts,
        owner
      }
    }, fee, memo, _funds);
  };
  updateMixnodeConfig = async ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config: {
        new_config: newConfig
      }
    }, fee, memo, _funds);
  };
  updateMixnodeConfigOnBehalf = async ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config_on_behalf: {
        new_config: newConfig,
        owner
      }
    }, fee, memo, _funds);
  };
  bondGateway = async ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway: {
        gateway,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  bondGatewayOnBehalf = async ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway_on_behalf: {
        gateway,
        owner,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  unbondGateway = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway: {}
    }, fee, memo, _funds);
  };
  unbondGatewayOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  delegateToMixnode = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  delegateToMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  undelegateFromMixnode = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  undelegateFromMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  rewardMixnode = async ({
    mixId,
    performance
  }: {
    mixId: number;
    performance: Percent;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reward_mixnode: {
        mix_id: mixId,
        performance
      }
    }, fee, memo, _funds);
  };
  withdrawOperatorReward = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward: {}
    }, fee, memo, _funds);
  };
  withdrawOperatorRewardOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  withdrawDelegatorReward = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  withdrawDelegatorRewardOnBehalf = async ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward_on_behalf: {
        mix_id: mixId,
        owner
      }
    }, fee, memo, _funds);
  };
}